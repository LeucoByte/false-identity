#!/usr/bin/env python3
"""Exhaustive test - 100 identities without family members."""

import sys
sys.path.insert(0, 'src')

from generator import IdentityGenerator, DataLoader
from datetime import datetime

def analyze_identity(identity, idx):
    """Analyze a single identity for coherence issues."""
    issues = []

    # Get basic info
    age = identity.age
    job = identity.job
    prev_job = identity.previous_job
    education = identity.education or ""
    education_lower = education.lower()
    social_class = identity.social_class

    # Determine actual job to check (retired/unemployed use previous job)
    job_to_check = prev_job if job in ["Retired", "Unemployed"] and prev_job else job

    # === EDUCATION CHECKS ===
    # High-skill jobs MUST have degrees
    if job_to_check:
        if job_to_check in ["Doctor", "Surgeon", "Dentist", "Veterinarian"] and "doctorate" not in education_lower and "bachelor" not in education_lower:
            issues.append(f"❌ {job_to_check} needs medical degree but has: {education}")
        elif job_to_check in ["Teacher", "Lawyer", "Engineer", "Software Engineer", "Architect", "Psychologist"] and "bachelor" not in education_lower and "master" not in education_lower:
            issues.append(f"❌ {job_to_check} needs university degree but has: {education}")
        elif job_to_check in ["Nurse", "Accountant"] and "bachelor" not in education_lower and "vocational" not in education_lower and "technical" not in education_lower:
            issues.append(f"❌ {job_to_check} needs nursing/accounting qualification but has: {education}")

    # === LANGUAGE CHECKS ===
    if identity.languages:
        # Count non-native languages
        non_native = [lang for lang in identity.languages if lang.get("level") != "Native"]

        # Check education vs languages
        if "incomplete" in education_lower or "no formal education" in education_lower:
            # Very low education
            if len(non_native) > 1:
                issues.append(f"❌ {education} but knows {len(non_native)} foreign languages: {[l.get('language') for l in non_native]}")
            elif len(non_native) == 1:
                level = non_native[0].get("level", "")
                if level in ["Advanced", "Intermediate"]:
                    issues.append(f"❌ {education} but has {level} level in {non_native[0].get('language')} (too high)")

        elif "primary" in education_lower and "incomplete" not in education_lower:
            # Primary education
            if len(non_native) > 1:
                issues.append(f"❌ {education} but knows {len(non_native)} foreign languages")
            elif len(non_native) == 1:
                level = non_native[0].get("level", "")
                if level == "Advanced":
                    issues.append(f"❌ {education} but has {level} level (should be Basic max)")

        # Language-intensive jobs MUST know languages
        language_jobs = ["Flight Attendant", "Tour Guide", "Hotel Receptionist", "Translator",
                        "Customer Service Representative", "Travel Agent", "Marketing Manager"]
        if job_to_check in language_jobs and len(non_native) < 2:
            issues.append(f"❌ {job_to_check} should know multiple languages, has only {len(non_native)}")

        # Check for suspicious advanced levels
        for lang_info in non_native:
            lang = lang_info.get("language", "")
            level = lang_info.get("level", "")

            if level == "Advanced":
                # Advanced level needs good education usually
                if "secondary" not in education_lower and "bachelor" not in education_lower and "master" not in education_lower and "vocational" not in education_lower and "technical" not in education_lower:
                    issues.append(f"❌ Advanced {lang} but low education: {education}")

    # === WORK EXPERIENCE CHECKS ===
    if identity.work_experience:
        exp = identity.work_experience

        # Check dates make sense
        if exp.get("start_date"):
            start_date = exp.get("start_date")
            # Parse year from date (format: DD/MM/YYYY or DD.MM.YYYY)
            try:
                if "/" in start_date:
                    start_year = int(start_date.split("/")[2])
                elif "." in start_date:
                    start_year = int(start_date.split(".")[2])
                else:
                    start_year = None

                if start_year:
                    current_year = datetime.now().year
                    years_working = current_year - start_year

                    # Can't have worked longer than possible
                    max_possible = age - 16
                    if years_working > max_possible:
                        issues.append(f"❌ Started job in {start_year} but only {age} years old (impossible)")

                    # Check if start year makes sense with job requirements
                    # Doctors need ~26 years, so can't start before age 26
                    job_min_ages = {
                        "Doctor": 26, "Surgeon": 28, "Dentist": 26, "Veterinarian": 26,
                        "Lawyer": 24, "Teacher": 22, "Nurse": 22, "Engineer": 22,
                        "Software Engineer": 22, "Architect": 23, "Psychologist": 24
                    }

                    if job_to_check in job_min_ages:
                        min_age_for_job = job_min_ages[job_to_check]
                        age_when_started = age - years_working
                        if age_when_started < min_age_for_job:
                            issues.append(f"❌ Started {job_to_check} at age {age_when_started} (needs to be {min_age_for_job}+)")
            except:
                pass  # Skip if can't parse

        # Check previous positions
        prev_positions = exp.get("previous_positions", [])
        if prev_positions:
            for prev in prev_positions:
                start = prev.get("start_date", "")
                end = prev.get("end_date", "")

                # Parse years
                try:
                    if "/" in start:
                        start_year = int(start.split("/")[2])
                        end_year = int(end.split("/")[2])
                    elif "." in start:
                        start_year = int(start.split(".")[2])
                        end_year = int(end.split(".")[2])
                    else:
                        continue

                    # End should be after start
                    if end_year < start_year:
                        issues.append(f"❌ Previous job ended ({end_year}) before it started ({start_year})")

                    # Check age when worked
                    age_at_start = age - (datetime.now().year - start_year)
                    if age_at_start < 16:
                        issues.append(f"❌ Previous job started when person was {age_at_start} years old")
                except:
                    pass

    return issues

def main():
    loader = DataLoader()
    gen = IdentityGenerator(loader)

    print("="*80)
    print("EXHAUSTIVE TESTING - 100 IDENTITIES")
    print("="*80)
    print()

    all_issues = []

    for i in range(100):
        # Generate identity WITHOUT family members
        identity = gen.generate(country='spain')

        # Analyze
        issues = analyze_identity(identity, i + 1)

        if issues:
            all_issues.append({
                'id': i + 1,
                'name': identity.full_name,
                'age': identity.age,
                'job': identity.job,
                'prev_job': identity.previous_job,
                'education': identity.education,
                'languages': identity.languages,
                'issues': issues
            })

        if (i + 1) % 20 == 0:
            print(f"Processed {i + 1}/100...")

    print()
    print("="*80)
    print("RESULTS")
    print("="*80)
    print()
    print(f"Total identities: 100")
    print(f"Identities with issues: {len(all_issues)}")
    print(f"Success rate: {100 - len(all_issues)}%")
    print()

    if all_issues:
        print("="*80)
        print("DETAILED ISSUES")
        print("="*80)
        print()

        for item in all_issues:
            print(f"#{item['id']}: {item['name']} ({item['age']} years, {item['job']})")
            if item['prev_job']:
                print(f"  Previous: {item['prev_job']}")
            if item['education']:
                print(f"  Education: {item['education']}")
            if item['languages']:
                langs_str = ", ".join([f"{l['language']} ({l['level']})" for l in item['languages']])
                print(f"  Languages: {langs_str}")
            for issue in item['issues']:
                print(f"  {issue}")
            print()
    else:
        print("✅ NO ISSUES FOUND - ALL IDENTITIES ARE CREDIBLE!")

if __name__ == "__main__":
    main()
